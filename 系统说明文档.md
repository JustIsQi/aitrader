# AITrader

## 目录
- [1. 项目概述](#1-项目概述)
- [2. 选股模块](#2-选股模块)
- [3. 买入卖出模块](#3-买入卖出模块)
- [4. 排序模块](#4-排序模块)
- [5. 组合权重模块](#5-组合权重模块)
- [6. 核心文件索引](#6-核心文件索引)

---

## 1. 项目概述

AITrader 是一个基于 Python 的完整量化交易系统，采用模块化设计，支持从数据获取、因子计算、策略实现到回测验证的全流程。

### 1.1 技术架构

```
┌─────────────────────────────────────────────────────────────┐
│                      AITrader v3.5                          │
├─────────────────────────────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ 数据获取模块  │  │ 因子计算模块  │  │ 策略回测模块  │      │
│  │ get_data.py  │  │ alpha/       │  │ bt_engine.py │      │
│  │ akshare      │  │ stock_engine │  │ backtrader_ │      │
│  └──────────────┘  └──────────────┘  │ engine.py    │      │
│                                        └──────────────┘      │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心特性

- **双引擎支持**: 基于 `bt` 和 `backtrader` 两种回测框架
- **灵活的因子系统**: 支持自定义因子表达式和 Alpha158 因子库
- **多种选股策略**: 条件筛选、TopK 排序、多因子组合
- **完善的交易执行**: 信号生成、订单管理、仓位控制
- **风险管理**: 止损、止盈、风险平价配置

---

## 2. 选股模块

选股模块提供两层架构，分别适用于不同场景：

### 2.1 架构对比

| 特性 | bt_engine.py | alpha/stock_engine.py |
|------|-------------|----------------------|
| 适用标的 | ETF、期货 | 个股 |
| 复杂度 | 简单、易用 | 支持复杂因子 |
| 选股方式 | TopK 排序 | 多条件筛选 + 排序 |
| 数据处理 | pandas | polars（高性能） |

### 2.2 选股工作流程

```
数据准备 → 规则解析 → 因子计算 → 条件筛选 → 排序选择 → 权重分配
```

#### 2.2.1 数据准备阶段

**核心类**: `DataFeed` ([bt_engine.py:78](bt_engine.py))

```python
class DataFeed:
    def __init__(self, task: Task):
        # 从 CSV 文件读取数据
        dfs = CsvDataLoader().read_dfs(
            symbols=task.symbols,
            start_date=task.start_date,
            end_date=task.end_date
        )
        # 计算因子表达式
        df_all = FactorExpr().calc_formulas(dfs, fields)
```

#### 2.2.2 规则解析阶段

**核心函数**: `_parse_rules()` ([bt_engine.py:107-144](bt_engine.py))

```python
def _parse_rules(self, task: Task):
    # 买入规则：满足 N 个条件才买入
    buy_at_least_count = task.buy_at_least_count
    all_buy = _rules(task.select_buy, at_least=buy_at_least_count)

    # 卖出规则：满足任意条件就卖出
    all_sell = _rules(task.select_sell, task.sell_at_least_count)

    return all_buy, all_sell
```

**信号逻辑**:
- 信号值 `1`: 执行买入/卖出
- 信号值 `0`: 不操作
- 信号值 `NaN`: 保持原仓位

#### 2.2.3 条件筛选算法

**SelectWhere** ([backtrader_algos.py:132](backtrader_algos.py))

根据条件信号选择标的：

```python
class SelectWhere:
    def __call__(self, target):
        current_date = target.datetime.date(0)
        current_date_pd = pd.Timestamp(current_date)

        if current_date_pd in signal.index:
            # 筛选信号值为 True 的标的
            selected_columns = signal.loc[current_date_pd][
                signal.loc[current_date_pd] == 1
            ].index.to_list()
            target.temp["selected"] = selected_columns
```

### 2.3 支持的因子类型

**定义位置**: [config.py:22-44](config.py)

#### 2.3.1 基础指标

| 因子名称 | 表达式 | 说明 |
|---------|-------|------|
| 开盘价 | `open` | 当日开盘价 |
| 最高价 | `high` | 当日最高价 |
| 最低价 | `low` | 当日最低价 |
| 收盘价 | `close` | 当日收盘价 |
| 成交量 | `volume` | 当日成交量 |
| 动量 | `roc(close,20)` | 20 日变化率 |
| 斜率 | `slope(close,25)` | 25 日线性回归斜率 |

#### 2.3.2 技术指标

| 因子名称 | 表达式 | 说明 |
|---------|-------|------|
| RSRS | `RSRS(high,low,18)` | 18 日 RSRS 指标 |
| RSRS 标准分 | `RSRS_zscore(high,low,18,600)` | 标准化 RSRS |
| 均线金叉 | `ma(close,5)>ma(close,20)` | 5 日均线 > 20 日均线 |
| 布林带上轨 | `close>bbands_up(close,20,2)` | 突破上轨 |
| 布林带下轨 | `close<bbands_down(close,20,2)` | 跌破下轨 |
| ATR | `ta_atr(high,low,close,14)` | 14 日 ATR |

### 2.4 选股任务配置

**Task 类** ([bt_engine.py:40-65](bt_engine.py))

```python
@dataclass
class Task:
    name: str = '策略'
    symbols: List[str] = field(default_factory=list)
    start_date: str = '20100101'
    end_date: str = datetime.now().strftime('%Y%m%d')

    # 选股相关
    select_buy: List[str] = field(default_factory=list)    # 买入条件
    buy_at_least_count: int = 0                           # 满足几个条件才买入
    select_sell: List[str] = field(default_factory=list)  # 卖出条件
    sell_at_least_count: int = 1                          # 满足几个条件才卖出

    # 排序相关
    order_by_signal: str = ''      # 排序因子
    order_by_topK: int = 1         # 选取前 K 个
    order_by_dropN: int = 0        # 丢弃前 N 个
    order_by_DESC: bool = True     # 是否降序

    # 权重相关
    weight: str = 'WeighEqually'   # 权重分配方式
    period: str = 'RunDaily'       # 调仓频率
```

### 2.5 实际选股策略示例

#### 2.5.1 优质资产动量轮动

```python
t = Task()
t.name = '优质资产动量轮动'
t.period = 'RunDaily'
t.select_buy = ['roc(close,20)>0.02']     # 20 日动量 > 2%
t.select_sell = ['roc(close,20)<-0.02']    # 20 日动量 < -2%
t.order_by_signal = 'roc(close,20)'
t.order_by_topK = 7                        # 选择前 7 个
```

---

## 3. 买入卖出模块

交易执行模块负责信号生成、订单处理和仓位管理。

### 3.1 信号生成流程

```
规则表达式 → 因子计算 → 信号矩阵 → 买卖决策
```

### 3.2 买卖规则解析

**核心函数**: `_parse_rules()` ([bt_engine.py:107](bt_engine.py))

```python
def _parse_rules(self, task: Task):
    def _rules(rules, at_least):
        if not rules or len(rules) == 0:
            return None

        all = None
        for r in rules:
            if r == '':
                continue
            df_r = self.datafeed.get_factor_df(r)
            if df_r is not None:
                df_r = df_r.replace({True: 1, False: 0})
                df_r = df_r.astype('Int64')
            if all is None:
                all = df_r
            else:
                all += df_r
        return all >= at_least

    # 解析买入条件
    buy_at_least_count = task.buy_at_least_count
    if buy_at_least_count <= 0:
        buy_at_least_count = len(task.select_buy)

    all_buy = _rules(task.select_buy, at_least=buy_at_least_count)
    all_sell = _rules(task.select_sell, task.sell_at_least_count)

    # 填充缺失值
    if all_sell is not None:
        all_sell = all_sell.fillna(True)   # NaN 保持持仓
    if all_buy is not None:
        all_buy = all_buy.fillna(False)    # NaN 不买入

    return all_buy, all_sell
```

### 3.3 订单通知处理

**函数**: `notify_order()` ([backtrader_strategy.py:25-43](backtrader_strategy.py))

```python
def notify_order(self, order):
    if order.status in [order.Submitted, order.Accepted]:
        return

    if order.status in [order.Completed]:
        if order.isbuy():
            self.log(f"买入执行, 价格: {order.executed.price:.2f},
                     数量: {order.executed.size},
                     成本: {order.executed.value:.2f},
                     佣金: {order.executed.comm:.2f}")
            self.buy_price = order.executed.price
            self.buy_date = self.datas[0].datetime.date(0)
        elif order.issell():
            profit = order.executed.value - order.created.value
            self.log(f"卖出执行, 价格: {order.executed.price:.2f},
                     数量: {order.executed.size},
                     收益: {profit:.2f},
                     佣金: {order.executed.comm:.2f}")

    elif order.status in [order.Canceled, order.Margin, order.Rejected]:
        self.log(f"订单取消/保证金不足/拒绝")
```

### 3.4 仓位调整逻辑

**函数**: `rebalance()` ([backtrader_strategy.py:133-163](backtrader_strategy.py))

```python
def rebalance(self, weights):
    total_value = self.broker.getvalue()
    to_buy = {}

    # 1. 计算每个标的的目标仓位
    for i, data in enumerate(self.datas):
        if data in weights.keys():
            target_value = total_value * weights[data]
        else:
            target_value = 0

        # 2. 计算需要调整的数量
        current_value = self.getposition(data).size * data.close[0]
        size_diff = (target_value - current_value) / data.close[0]

        # 3. 先卖出需要减仓的
        if size_diff > 0:
            to_buy[data] = size_diff
        elif size_diff < 0:
            self.sell(data=data, size=abs(size_diff))

    # 4. 再买入需要加仓的
    for data, size in to_buy.items():
        self.buy(data=data, size=size)
```

### 3.5 交易成本

**计算方式**:
```python
commissions = lambda q, p: max(5, abs(q*p) * 0.0003)
```

- 最低佣金: 5 元
- 费率: 0.03%

### 3.6 交易统计

**函数**: `notify_trade()` ([backtrader_strategy.py:250-299](backtrader_strategy.py))

记录每笔交易的：
- 买入日期、价格
- 卖出日期、价格
- 持仓天数
- 盈亏金额
- 盈亏比例

---

## 4. 排序模块

排序模块负责根据因子值对标的进行排序和选择。

### 4.1 SelectTopK 算法

#### 4.1.1 bt 版本

**位置**: [bt_engine.py:10](bt_engine.py)

```python
class SelectTopK(bt.AlgoStack):
    def __init__(self, signal, K=1, dropN=0, sort_descending=True,
                 all_or_none=False, filter_selected=True):
        super(SelectTopK, self).__init__(
            bt.algos.SetStat(signal),
            bt.algos.SelectN(int(K) + int(dropN), sort_descending,
                           all_or_none, filter_selected)
        )
        self.dropN = dropN

    def __call__(self, target):
        super(SelectTopK, self).__call__(target)

        if self.dropN > 0:
            sel = target.temp["selected"]
            if self.dropN >= len(sel):
                target.temp['selected'] = []
            else:
                # 丢弃前 N 个最强的（防止过拟合）
                target.temp["selected"] = target.temp["selected"][self.dropN:]
        return True
```

#### 4.1.2 backtrader 版本

**位置**: [backtrader_algos.py:163](backtrader_algos.py)

```python
class SelectTopK:
    def __init__(self, signal, K=1, drop_top_n=0, b_ascending=False):
        self.K = K                    # 选取前 K 个
        self.drop_top_n = drop_top_n  # 丢弃前 N 个
        self.b_ascending = b_ascending # 排序方向
        self.signal = signal          # 信号 DataFrame

    def __call__(self, target):
        current_date = target.datetime.date()
        current_date_pd = pd.Timestamp(current_date)

        if current_date_pd not in signal.index:
            target.temp["selected"] = []
            return True

        # 获取当前日期的信号值
        daily_signals = signal.loc[current_date_pd]

        # 从已选择的标的中筛选
        if 'selected' in target.temp.keys():
            selected = target.temp['selected']
            if selected:
                valid_signals = daily_signals[selected]
            else:
                return True
        else:
            return False

        # 按信号值排序
        sorted_signals = valid_signals.sort_values(
            ascending=self.b_ascending
        )

        # 丢弃前 N 个
        N = int(self.drop_top_n) if self.drop_top_n else 0
        if N > 0:
            N = min(N, len(sorted_signals))
            sorted_signals = sorted_signals.iloc[N:]

        # 选取前 K 个
        K = int(self.K)
        if len(sorted_signals) > 0:
            K = min(K, len(sorted_signals))
            topK_signals = sorted_signals.head(K)
            target.temp["selected"] = topK_signals.index.tolist()
        else:
            target.temp["selected"] = []

        return True
```

### 4.2 趋势评分算法

**核心评分指标**，位置: [backtrader_engine.py:475](backtrader_engine.py)

```python
trend_score(close,25)*0.27 + roc(close,13)*0.75 +
roc(close,8)*0.18 + roc(high,5)*0.6 + ma(volume,5)/ma(volume,20)
```

#### 4.2.1 trend_score 计算逻辑

```python
def trend_score(close: pd.Series, period: int = 25):
    """
    趋势评分 = 年化收益率 × R²
    """
    for i in range(period - 1, len(close)):
        window = close[i - period + 1:i + 1]

        # 1. 对数转换
        y = np.log(window.values)
        x = np.arange(len(y))

        # 2. 线性回归
        n = len(y)
        slope = (n * sum_xy - sum_x * sum_y) / denominator

        # 3. 计算 R²
        y_pred = slope * x + intercept
        ss_res = np.sum((y - y_pred) ** 2)
        ss_tot = np.sum(y ** 2) - (sum_y ** 2) / n
        r_squared = 1 - ss_res / ss_tot

        # 4. 年化收益率
        annualized_return = np.exp(slope * 250) - 1

        # 5. 综合评分
        result[i] = annualized_return * r_squared

    return result
```

**设计思想**:
- **年化收益率**: 衡量上涨趋势的强度
- **R²**: 衡量趋势的稳定性
- **综合评分**: 只选择上涨稳定且幅度大的标的

### 4.3 排序策略类型

#### 4.3.1 动量轮动

```python
order_by_signal = 'roc(close,20)'  # 按动量排序
order_by_topK = 3
order_by_dropN = 0
```

#### 4.3.2 防过拟合轮动

```python
order_by_signal = 'roc(close,20)'
order_by_topK = 3
order_by_dropN = 1  # 丢弃最强的 1 个，避免追高
```

#### 4.3.3 多因子合成

```python
order_by_signal = (
    'trend_score(close,25)*0.27 + '  # 趋势评分
    'roc(close,13)*0.75 + '           # 短期动量
    'roc(close,8)*0.18 + '            # 超短期动量
    'ma(volume,5)/ma(volume,20)'      # 成交量放大
)
```

### 4.4 排序参数说明

| 参数 | 类型 | 说明 |
|------|------|------|
| `order_by_signal` | str | 排序因子表达式 |
| `order_by_topK` | int | 选取前 K 个标的 |
| `order_by_dropN` | int | 丢弃前 N 个最强标的 |
| `order_by_DESC` | bool | True=降序（从大到小） |

---

## 5. 组合权重模块

权重模块负责确定选中标的的资金分配比例。

### 5.1 权重分配方式

#### 5.1.1 等权重分配

**类**: `WeightEqually` ([backtrader_algos.py:234](backtrader_algos.py))

```python
class WeightEqually:
    def __call__(self, target):
        selected = target.temp["selected"]
        n = len(selected)

        if n == 0:
            target.temp["weights"] = {}
        else:
            w = 1.0 / n
            target.temp["weights"] = {x: w for x in selected}
        return True
```

**特点**: 简单、适合相似风险特征的标的

#### 5.1.2 风险平价分配

**实现**:
```python
def weight_risk_parity(self, data_selected):
    # 1. 准备历史收益率数据
    df_returns = self._prepare_returns(data_selected)

    # 2. 调用 ffn 库计算 ERC 权重
    weights = ffn.core.calc_erc_weights(
        returns=df_returns,
        covar_method='custom',
        risk_parity_method='ccd',
        maximum_iterations=100,
        tolerance=1e-8
    )

    # 3. 留 0.5% 现金缓冲
    weights = weights.values * 0.995

    return {data: w for data, w in zip(data_selected, weights)}
```

**特点**:
- 根据风险贡献分配权重
- 适合波动率差异大的标的
- 有效分散组合风险

#### 5.1.3 固定权重分配

```python
class WeightFix:
    def __init__(self, weights_dict: dict):
        self.weights_dict = weights_dict
        total_weight = sum(self.weights_dict.values())
        if total_weight > 1:
            raise ValueError("权重和不能大于1")

    def __call__(self, target):
        target.temp["weights"] = self.weights_dict
```

**使用示例**:
```python
weights = {
    '510300.SH': 0.5,  # 沪深300 ETF 50%
    '510500.SH': 0.3,  # 中证500 ETF 30%
    '现金': 0.2
}
```

### 5.2 权重配置

在 `Task` 类中配置：

```python
# 使用等权重
weight = 'WeighEqually'

# 使用风险平价
weight = 'WeighRiskParity'

# 使用固定权重
weight = 'WeighFix'
weight_fixed = {'510300.SH': 0.6, '510500.SH': 0.4}
```

---

## 6. 核心文件索引

### 6.1 引擎文件

| 文件 | 路径 | 说明 |
|------|------|------|
| BT 引擎 | [bt_engine.py](bt_engine.py) | 基于 bt 库的回测引擎 |
| Backtrader 引擎 | [backtrader_engine.py](backtrader_engine.py) | 基于 backtrader 的回测引擎 |
| Backtrader 策略 | [backtrader_strategy.py](backtrader_strategy.py) | Backtrader 策略模板 |
| 算法库 | [backtrader_algos.py](backtrader_algos.py) | 自定义算法实现 |

### 6.2 数据处理文件

| 文件 | 路径 | 说明 |
|------|------|------|
| 配置 | [config.py](config.py) | 因子定义和路径配置 |
| CSV 加载器 | [datafeed/csv_dataloader.py](datafeed/csv_dataloader.py) | CSV 数据加载 |
| 因子表达式 | [datafeed/factor_expr.py](datafeed/factor_expr.py) | 因子计算引擎 |
| 数据获取 | [get_data.py](get_data.py) | Akshare 数据下载 |

### 6.3 Alpha 模块

| 文件 | 路径 | 说明 |
|------|------|------|
| 股票引擎 | [alpha/stock_engine.py](alpha/stock_engine.py) | 股票因子引擎 |
| 因子引擎 | [alpha/factor_engine.py](alpha/factor_engine.py) | 因子计算主程序 |

### 6.4 策略示例

| 策略 | 路径 | 说明 |
|------|------|------|
| 多资产轮动 | [策略集/backtrader-多资产轮动-趋势评分.py](策略集/backtrader-多资产轮动-趋势评分.py) | 趋势评分轮动 |
| 风险平价 | [策略集/backtrader_风险平价.py](策略集/backtrader_风险平价.py) | 风险平价配置 |
| 超级轮动 | [策略集/年化收益评分的轮动策略-超级轮动.py](策略集/年化收益评分的轮动策略-超级轮动.py) | 多因子轮动 |
| RSRS 择时 | [策略集/沪深300ETF的RSRS择时.py](策略集/沪深300ETF的RSRS择时.py) | RSRS 择时策略 |

---

## 附录：快速上手指南

### A.1 运行一个简单策略

```python
from bt_engine import Task, Engine

# 创建策略任务
t = Task()
t.name = '动量轮动策略'
t.symbols = ['510300.SH', '510500.SH', '159915.SZ']
t.start_date = '20200101'
t.end_date = '20231231'

# 配置选股参数
t.order_by_signal = 'roc(close,20)'  # 按动量排序
t.order_by_topK = 2                   # 选择前 2 个

# 配置权重和频率
t.weight = 'WeighEqually'             # 等权重
t.period = 'RunWeekly'                # 每周调仓

# 运行回测
e = Engine()
e.run(t)
e.stats()
e.plot()
```

### A.2 添加买卖条件

```python
t.select_buy = [
    'roc(close,20)>0.02',              # 20 日动量 > 2%
    'ma(close,5)>ma(close,20)'         # 5 日均线 > 20 日均线
]
t.buy_at_least_count = 1               # 满足 1 个条件即可

t.select_sell = [
    'roc(close,20)<-0.02'              # 20 日动量 < -2%
]
t.sell_at_least_count = 1              # 满足 1 个条件即卖出
```

### A.3 使用多因子排序

```python
t.order_by_signal = (
    'trend_score(close,25)*0.3 + '     # 趋势评分 30%
    'roc(close,13)*0.5 + '             # 动量 50%
    'ma(volume,5)/ma(volume,20)*0.2'   # 成交量 20%
)
t.order_by_topK = 5
t.order_by_dropN = 1                   # 丢弃最强的 1 个
```

---

## 版本信息

- **项目名称**: AITrader v3.5
- **文档日期**: 2025-12-23
- **Python 版本**: 3.x
- **主要依赖**: backtrader, bt, pandas, numpy, ffn
